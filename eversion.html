<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Elastic Sphere</title>
<style>
body, html {
  margin: 0px;
  width: 100%;
  height: 100%;
  background-color: rgb(85,85,85);
}
#example {
  width: 1000px;
  height: 1000px;
  float: left;
}
#loading {
  color: white;
  position:absolute;
  top: 10px;
  left: 10px;
}
#controls {
  color: white;
  float: left;
  padding: 10px;
  width: 300px;
}
#text {
  float: left;
  color: white;
  padding: 10px;
  width: 910px;
}
</style>

<script id="shader-vs-show-1" type="x-shader/x-vertex"> 
    precision mediump float;
    uniform mat4 u_modelViewProjMatrix;
    uniform mat3 modelViewMatrix;
    uniform vec3 basecolor;
    uniform float shininess;
    uniform float t;

    attribute vec4 vp1;
    attribute vec4 vp2;
    attribute vec4 avp11;
    attribute vec4 avp21;
    attribute vec4 avp31;
    attribute vec4 avp41;
    attribute vec4 avp51;
    attribute vec4 avp61;
    attribute vec4 avp12;
    attribute vec4 avp22;
    attribute vec4 avp32;
    attribute vec4 avp42;
    attribute vec4 avp52;
    attribute vec4 avp62;
    

    varying vec3 vc;
    varying vec3 vn;
    varying vec3 vp;

    const float PI = 3.14159265359;

    vec3 interpolate(vec4 start1, vec4 end1, float t) {
    float offset = -2.*start1.w;
    vec3 start = vec3(start1.x,start1.y,start1.z-offset);
    vec3 end = vec3(end1.x,end1.y,end1.z-offset);
    vec3 midpoint = (start+end)/2.;
    vec3 nmidpoint = normalize(midpoint);
    float d1 = dot(start,nmidpoint);
    float d2 = dot(end,nmidpoint);
    vec3 pstart = start-d1*nmidpoint;
    vec3 pend = end-d2*nmidpoint;
    vec3 b2 = cross(nmidpoint,pstart);

    vec3 rot = cos(t*PI)*pstart+sin(t*PI)*b2;
    return rot+((1.-t)*d1+t*d2)*nmidpoint+vec3(0.,0.,offset);
    } 


    void main()
    {
        vec3 p1 = interpolate(vp1,vp2,t);
        gl_Position = u_modelViewProjMatrix * vec4(p1, 1.0);
        vec3 vpos[6];
        vpos[0] = interpolate(avp11,avp12,t)-p1;
        vpos[1] = interpolate(avp21,avp22,t)-p1;
	vpos[2] = interpolate(avp31,avp32,t)-p1;
        vpos[3] = interpolate(avp41,avp42,t)-p1;
        vpos[4] = interpolate(avp51,avp52,t)-p1;
        vpos[5] = interpolate(avp61,avp62,t)-p1;
	vec3 n1 = cross(vpos[0],vpos[1]);
	n1 = n1+cross(vpos[1],vpos[2]); 
	n1 = n1+cross(vpos[2],vpos[3]);
	n1 = n1+cross(vpos[3],vpos[4]);
	float stepper = step(0.,-length(avp61));
	n1 = n1+stepper*cross(vpos[4],vpos[0]);
	n1 = n1+(1.-stepper)*cross(vpos[4],vpos[5]);
	n1 = n1+(1.-stepper)*cross(vpos[5],vpos[0]);
	vn = modelViewMatrix*n1;
	vc = basecolor;
	vp = p1;
    }
</script> 

<script id="shader-vs-show-2" type="x-shader/x-vertex"> 
    precision mediump float;
    uniform mat4 u_modelViewProjMatrix;
    uniform mat3 modelViewMatrix;
    uniform vec3 basecolor;
    uniform float shininess;
    uniform float t;

    attribute vec4 vp1;
    attribute vec4 vp2;
    attribute vec4 avp11;
    attribute vec4 avp21;
    attribute vec4 avp31;
    attribute vec4 avp41;
    attribute vec4 avp51;
    attribute vec4 avp61;
    attribute vec4 avp12;
    attribute vec4 avp22;
    attribute vec4 avp32;
    attribute vec4 avp42;
    attribute vec4 avp52;
    attribute vec4 avp62;
    

    varying vec3 vc;
    varying vec3 vn;
    varying vec3 vp;

    const float PI = 3.14159265359;

    vec3 interpolate(vec4 start, vec4 end, float t) {
    return (1.-t)*start.xyz+t*end.xyz;
    }


    void main()
    {
        vec3 p1 = interpolate(vp1,vp2,t);
        gl_Position = u_modelViewProjMatrix * vec4(p1, 1.0);
        vec3 vpos[6];
        vpos[0] = interpolate(avp11,avp12,t)-p1;
        vpos[1] = interpolate(avp21,avp22,t)-p1;
	vpos[2] = interpolate(avp31,avp32,t)-p1;
        vpos[3] = interpolate(avp41,avp42,t)-p1;
        vpos[4] = interpolate(avp51,avp52,t)-p1;
        vpos[5] = interpolate(avp61,avp62,t)-p1;
	vec3 n1 = cross(vpos[0],vpos[1]);
	n1 = n1+cross(vpos[1],vpos[2]); 
	n1 = n1+cross(vpos[2],vpos[3]);
	n1 = n1+cross(vpos[3],vpos[4]);
	float stepper = step(0.,-length(avp61));
	n1 = n1+stepper*cross(vpos[4],vpos[0]);
	n1 = n1+(1.-stepper)*cross(vpos[4],vpos[5]);
	n1 = n1+(1.-stepper)*cross(vpos[5],vpos[0]);
	vn = modelViewMatrix*n1;
	vc = basecolor;
	vp = p1;
    }
</script> 
 
<script id="shader-fs-show" type="x-shader/x-fragment"> 
precision mediump float;
    varying vec3 vc;
    varying vec3 vn;
    varying vec3 vp; 
    uniform vec3 basecolor;
    uniform float shininess;

    void main()
    {
	vec3 vnormal = normalize(vn);
	vec3 vpos = normalize(-vp+vec3(0.0,0.0,5.0));
	vec3 rm = normalize(2.0*vnormal.z*vnormal-vec3(0.0,0.0,1.0));
	float val = clamp(dot(rm,vpos),0.0,1.0);
	val = val*val;
	val = val*val;
	val = val*val;
	val = val*val*shininess*0.3;
        gl_FragColor = vec4(clamp(vnormal.z,0.0,1.0)*vc+0.1*basecolor+vec3(val,val,val),1.0);
     }
</script> 

<script>
var gl;
var curRotQ = [1.0,0.0,0.0,0.0];
var buffer0, buffer1, buffer2, buffer3, buffer4;
var sin = Math.sin;
var cos = Math.cos;
var pi = Math.PI;

function position(mesh, fn) { //fn outputs cartesian from spherical coordinate input
var output = [];
for (var i = 0; i < mesh.length; i += 2) output.push.apply(output,fn(mesh[i],mesh[i+1]));
return output;
}

function c1ProfileFn(t,margin) {
if (t < margin || 1-t < margin) return 0;
if (t > 0.5) t = 1-t;
if (t < 0.5*(0.5+margin)) return 0.5*(t-margin)*(t-margin)/(0.25-0.5*margin)/(0.25-0.5*margin);
t = t-2*(t-0.5*(0.5+margin));
return 1-0.5*(t-margin)*(t-margin)/(0.25-0.5*margin)/(0.25-0.5*margin);
}

var params = {"r1": 10, "r2": -64, "b": 3, "a": 0.2, "loops": 6, "R": 1, "thetadivisions": 200, "phidivisions": 100};

var thetafnNormalized = function(s,p) {
return [(p.r1*(p.b+sin(p.loops*s))*cos(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*cos(s))*p.R/(p.r1+Math.abs(p.r2)),
(p.r1*(p.b+sin(p.loops*s))*sin(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*sin(s))*p.R/(p.r1+Math.abs(p.r2))];
};

var thetafnNormalizedStaggered = function(s,p,stagger) {
return [(p.r1*(p.b+sin(p.loops*(s+stagger)))*cos(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*cos(s))*p.R/(p.r1+Math.abs(p.r2)),
(p.r1*(p.b+sin(p.loops*(s+stagger)))*sin(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*sin(s))*p.R/(p.r1+Math.abs(p.r2))];
};

var thetafn = function(s,p) {
return [(p.r1*(p.b+sin(p.loops*s))*cos(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*cos(s))*p.R/(p.r1*(p.b+1)+p.r2),
(p.r1*(p.b+sin(p.loops*s))*sin(p.a*cos(2*p.loops*s-pi/2)+s)+p.r2*sin(s))*p.R/(p.r1*(p.b+1)+p.r2)];
};

var fn0 = function (theta, phi) { //initial sphere
return [params.R*Math.cos(theta)*Math.sin(phi),params.R*Math.sin(theta)*Math.sin(phi),params.R*Math.cos(phi)];
};

var fn1 = function (theta, phi) { //initial corrugations
var xy = thetafnNormalized(theta,params);
return [-2*xy[0]*Math.sin(phi)*c1ProfileFn(phi/Math.PI,0.2)+params.R*Math.cos(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.2)),
-2*xy[1]*Math.sin(phi)*c1ProfileFn(phi/Math.PI,0.2)+params.R*Math.sin(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.2)),params.R*Math.cos(phi)];
};
//+params.R*Math.sin(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.1))
//*(1-c1ProfileFn(phi/Math.PI,0.2))

var fn2 = function (theta, phi) { //north and south pole interchanged
//stagger to get correct alignment for twisting phase
var cutoff = 0.2;

var xy = thetafnNormalizedStaggered(theta,params,Math.PI/params.loops);
var radius = Math.sqrt(xy[0]*xy[0]+xy[1]*xy[1]); //should never be zero with correct params
var normalized = [xy[0]/radius, xy[1]/radius];
var residual = [xy[0]-0.3*normalized[0],xy[1]-0.3*normalized[1]];
var residualR = radius-0.3;
var perp = [-sin(-sin(2*phi)+pi-phi)*(-2*cos(2*phi)-1),cos(phi)];
var nperp = [perp[0]/(Math.sqrt(perp[0]*perp[0]+perp[1]*perp[1])),perp[1]/(Math.sqrt(perp[0]*perp[0]+perp[1]*perp[1]))];
return [(-normalized[0]*Math.sin(phi)+3*residual[0]*nperp[0]*c1ProfileFn(phi/Math.PI,cutoff)),
(-normalized[1]*Math.sin(phi)+3*residual[1]*nperp[0]*c1ProfileFn(phi/Math.PI,cutoff)),
2*(params.R*Math.cos(-Math.sin(2*phi)+Math.PI-phi)+nperp[1]*3*residualR*c1ProfileFn(phi/Math.PI,cutoff))];
};
//*(1-c1ProfileFn(phi/Math.PI,0.2))
//+params.R*Math.cos(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.0))
//+params.R*Math.sin(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.0))

var fn3 = function (theta, phi) { //after twisting
var r1 = 50*c1ProfileFn(phi/pi,0.2);
var p = {"r1": r1, "r2": -64, "b": 3, "a": 0.2, "loops": 6, "R": 1};
var xy = thetafnNormalized(theta,p);
return [xy[0]*Math.sin(phi),
xy[1]*Math.sin(phi),-2*params.R*Math.cos(phi)];
};
//+params.R*Math.sin(theta)*Math.sin(phi)*(1-c1ProfileFn(phi/Math.PI,0.1))

var fn4 = function (theta, phi) { //everted
var xy = thetafn(theta,params);
return [-params.R*Math.cos(theta)*Math.sin(phi),-params.R*Math.sin(theta)*Math.sin(phi),-params.R*Math.cos(phi)];
};


function sphericalMesh(thetadivisions, phidivisions) {
var mesh = {};
//mesh.points = [];
//mesh.points.push(0,0,1);
mesh.points_spherical = [];
mesh.points_spherical.push(0,0);
for (var i = 1; i < phidivisions; i++) {
var phiangle = i*Math.PI/phidivisions;
for (var j = 0; j < thetadivisions; j++) {
var thetaangle = j*2*Math.PI/thetadivisions;
//mesh.points.push(Math.sin(phiangle)*Math.cos(thetaangle),Math.sin(phiangle)*Math.sin(thetaangle),Math.cos(phiangle));
mesh.points_spherical.push(thetaangle,phiangle);
}
}
//mesh.points.push(0,0,-1);
mesh.points_spherical.push(Math.PI,0);
mesh.triangles = [];
for (var i = 0; i < thetadivisions; i++) mesh.triangles.push(0,(i+1)%thetadivisions+1,i+1);
for (var j = 1; j < phidivisions-1; j++) {
for (var i = 0; i < thetadivisions; i++) {
mesh.triangles.push(getindex(i,j,thetadivisions),getindex(i+1,j,thetadivisions),getindex(i+1,j+1,thetadivisions));
mesh.triangles.push(getindex(i,j,thetadivisions),getindex(i+1,j+1,thetadivisions),getindex(i,j+1,thetadivisions));
}
}
for (var i = 0; i < thetadivisions; i++) mesh.triangles.push(i+1,(i+1)%thetadivisions+1,(phidivisions-1)*thetadivisions+1);
mesh.av = [];
mesh.av[0] = [];
mesh.av[1] = [];
mesh.av[2] = [];
mesh.av[3] = [];
mesh.av[4] = [];
mesh.av[5] = [];

var PAST_END = (phidivisions-1)*thetadivisions+2;

//phidivisions-1)*thetadivisions+2 is one past the end of the "real" array of numbers
//indicates that we won't really be using an adjacent point to calculate normal vectors.  This happens at/near poles. 
for (var i = 0; i < 6; i++) mesh.av[i].push(PAST_END);
for (var i = 0; i < thetadivisions; i++) {
mesh.av[0].push(0); //adjacent mesh points in counterclockwise order
mesh.av[1].push((i-1+thetadivisions)%thetadivisions+1);
mesh.av[2].push(getindex(i,2,thetadivisions));
mesh.av[3].push(getindex(i+1,2,thetadivisions));
mesh.av[4].push((i+1)%thetadivisions+1);
mesh.av[5].push(PAST_END);
}
for (var j = 2; j < phidivisions-1; j++) {
for (var i = 0; i < thetadivisions; i++) {
mesh.av[0].push(getindex(i+1,j,thetadivisions));
mesh.av[1].push(getindex(i,j-1,thetadivisions));
mesh.av[2].push(getindex(i-1,j-1,thetadivisions));
mesh.av[3].push(getindex(i-1,j,thetadivisions));
mesh.av[4].push(getindex(i,j+1,thetadivisions));
mesh.av[5].push(getindex(i+1,j+1,thetadivisions));
}
}
for (var i = 0; i < thetadivisions; i++) {
mesh.av[0].push((phidivisions-1)*thetadivisions+1);
mesh.av[1].push(getindex(i+1,j,thetadivisions));
mesh.av[2].push(getindex(i,j-1,thetadivisions));
mesh.av[3].push(getindex(i-1,j-1,thetadivisions));
mesh.av[4].push(getindex(i-1,j,thetadivisions));
mesh.av[5].push(PAST_END);
}
for (var i = 0; i < 6; i++) mesh.av[i].push(PAST_END);
return mesh;
}

	function getindex(i,j,thetadivisions,phidivisions) {
	return (j-1)*thetadivisions+(i+thetadivisions)%thetadivisions+1;
	}

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    //quaternion multiplication
    function qMultiply(q1, q2) {
	return [q1[0]*q2[0]-q1[1]*q2[1]-q1[2]*q2[2]-q1[3]*q2[3],
		q1[0]*q2[1]+q1[1]*q2[0]+q1[2]*q2[3]-q1[3]*q2[2],
		q1[0]*q2[2]-q1[1]*q2[3]+q1[2]*q2[0]+q1[3]*q2[1],
		q1[0]*q2[3]+q1[1]*q2[2]-q1[2]*q2[1]+q1[3]*q2[0]];
    }

    //quaternion normalization
    function qNormalize(q) {
	var norm = Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]+q[3]*q[3]);
	if (norm != 0) return [q[0]/norm, q[1]/norm, q[2]/norm, q[3]/norm];
	else return q;
    }

    var indexBuffer, numPts, drawLength, rotMatrix, projectionMatrix, modelviewMatrix;
    var err = "Your browser does not support ";

   var gl, canvas,
    prog,
    mvpMatrixLoc, mvMatrixLoc, basecolorLoc, shininessLoc, tLoc, indexBuffer;

    function initShaders() {
	projectionMatrix = new J3DIMatrix4();
        projectionMatrix.perspective(45, maincanvas.clientWidth / maincanvas.clientHeight, 0.1, 100.0);
	projmat = projectionMatrix.getAsArray();
	modelviewMatrix = new J3DIMatrix4();
	modelviewMatrix.load([1,0,0,0,0,1,0,0,0,0,1,0,0,0,-5,1]);
	projectionMatrix.multiply(modelviewMatrix);
	rotMatrix = new J3DIMatrix4();

	for (var i = 0; i < 14; i++) gl.enableVertexAttribArray(i);

        prog  = gl.createProgram();
        gl.bindAttribLocation(prog, 0, "vp1");
        gl.bindAttribLocation(prog, 1, "avp11");
        gl.bindAttribLocation(prog, 2, "avp21");
        gl.bindAttribLocation(prog, 3, "avp31");
        gl.bindAttribLocation(prog, 4, "avp41");
        gl.bindAttribLocation(prog, 5, "avp51");
        gl.bindAttribLocation(prog, 6, "avp61");
	gl.bindAttribLocation(prog, 7, "vp2");
        gl.bindAttribLocation(prog, 8, "avp12");
        gl.bindAttribLocation(prog, 9, "avp22");
        gl.bindAttribLocation(prog, 10, "avp32");
        gl.bindAttribLocation(prog, 11, "avp42");
        gl.bindAttribLocation(prog, 12, "avp52");
        gl.bindAttribLocation(prog, 13, "avp62");
        gl.attachShader(prog, getShader( gl, "shader-vs-show-1" ));
        gl.attachShader(prog, getShader( gl, "shader-fs-show" ));
        gl.linkProgram(prog);
	//alert(gl.getProgramInfoLog(prog));

	prog2  = gl.createProgram();
        gl.bindAttribLocation(prog2, 0, "vp1");
        gl.bindAttribLocation(prog2, 1, "avp11");
        gl.bindAttribLocation(prog2, 2, "avp21");
        gl.bindAttribLocation(prog2, 3, "avp31");
        gl.bindAttribLocation(prog2, 4, "avp41");
        gl.bindAttribLocation(prog2, 5, "avp51");
        gl.bindAttribLocation(prog2, 6, "avp61");
	gl.bindAttribLocation(prog2, 7, "vp2");
        gl.bindAttribLocation(prog2, 8, "avp12");
        gl.bindAttribLocation(prog2, 9, "avp22");
        gl.bindAttribLocation(prog2, 10, "avp32");
        gl.bindAttribLocation(prog2, 11, "avp42");
        gl.bindAttribLocation(prog2, 12, "avp52");
        gl.bindAttribLocation(prog2, 13, "avp62");
        gl.attachShader(prog2, getShader( gl, "shader-vs-show-2" ));
        gl.attachShader(prog2, getShader( gl, "shader-fs-show" ));        
	gl.linkProgram(prog2);
	//alert(gl.getProgramInfoLog(prog2));

	mesh = sphericalMesh(params.thetadivisions, params.phidivisions);

	points0 = position(mesh.points_spherical, fn0);
	points1 = position(mesh.points_spherical, fn1);
	points2 = position(mesh.points_spherical, fn2);
	points3 = position(mesh.points_spherical, fn3);
	points4 = position(mesh.points_spherical, fn4);
	points0.push(0,0,0);
	points1.push(0,0,0);
	points2.push(0,0,0);
	points3.push(0,0,0);
	points4.push(0,0,0);

	buffer0data = [];
	buffer1data = [];
	buffer2data = [];
	buffer3data = [];
	buffer4data = [];

	for (var i = 0; i < mesh.points_spherical.length/2; i++) {
		buffer0data.push(points0[3*i],points0[3*i+1],points0[3*i+2],0,
				 points0[3*mesh.av[0][i]],points0[3*mesh.av[0][i]+1],points0[3*mesh.av[0][i]+2],0,
				 points0[3*mesh.av[1][i]],points0[3*mesh.av[1][i]+1],points0[3*mesh.av[1][i]+2],0,
				 points0[3*mesh.av[2][i]],points0[3*mesh.av[2][i]+1],points0[3*mesh.av[2][i]+2],0,
				 points0[3*mesh.av[3][i]],points0[3*mesh.av[3][i]+1],points0[3*mesh.av[3][i]+2],0,
				 points0[3*mesh.av[4][i]],points0[3*mesh.av[4][i]+1],points0[3*mesh.av[4][i]+2],0,
				 points0[3*mesh.av[5][i]],points0[3*mesh.av[5][i]+1],points0[3*mesh.av[5][i]+2],0);
		buffer1data.push(points1[3*i],points1[3*i+1],points1[3*i+2],0,
				 points1[3*mesh.av[0][i]],points1[3*mesh.av[0][i]+1],points1[3*mesh.av[0][i]+2],0,
				 points1[3*mesh.av[1][i]],points1[3*mesh.av[1][i]+1],points1[3*mesh.av[1][i]+2],0,
				 points1[3*mesh.av[2][i]],points1[3*mesh.av[2][i]+1],points1[3*mesh.av[2][i]+2],0,
				 points1[3*mesh.av[3][i]],points1[3*mesh.av[3][i]+1],points1[3*mesh.av[3][i]+2],0,
				 points1[3*mesh.av[4][i]],points1[3*mesh.av[4][i]+1],points1[3*mesh.av[4][i]+2],0,
				 points1[3*mesh.av[5][i]],points1[3*mesh.av[5][i]+1],points1[3*mesh.av[5][i]+2],0);
		buffer2data.push(points2[3*i],points2[3*i+1],points2[3*i+2],params.R*Math.cos(mesh.points_spherical[2*i+1]),
				 points2[3*mesh.av[0][i]],points2[3*mesh.av[0][i]+1],points2[3*mesh.av[0][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[0][i]+1]),
				 points2[3*mesh.av[1][i]],points2[3*mesh.av[1][i]+1],points2[3*mesh.av[1][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[1][i]+1]),
				 points2[3*mesh.av[2][i]],points2[3*mesh.av[2][i]+1],points2[3*mesh.av[2][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[2][i]+1]),
				 points2[3*mesh.av[3][i]],points2[3*mesh.av[3][i]+1],points2[3*mesh.av[3][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[3][i]+1]),
				 points2[3*mesh.av[4][i]],points2[3*mesh.av[4][i]+1],points2[3*mesh.av[4][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[4][i]+1]),
				 points2[3*mesh.av[5][i]],points2[3*mesh.av[5][i]+1],points2[3*mesh.av[5][i]+2],params.R*Math.cos(mesh.points_spherical[2*mesh.av[5][i]+1]));
		buffer3data.push(points3[3*i],points3[3*i+1],points3[3*i+2],0,
				 points3[3*mesh.av[0][i]],points3[3*mesh.av[0][i]+1],points3[3*mesh.av[0][i]+2],0,
				 points3[3*mesh.av[1][i]],points3[3*mesh.av[1][i]+1],points3[3*mesh.av[1][i]+2],0,
				 points3[3*mesh.av[2][i]],points3[3*mesh.av[2][i]+1],points3[3*mesh.av[2][i]+2],0,
				 points3[3*mesh.av[3][i]],points3[3*mesh.av[3][i]+1],points3[3*mesh.av[3][i]+2],0,
				 points3[3*mesh.av[4][i]],points3[3*mesh.av[4][i]+1],points3[3*mesh.av[4][i]+2],0,
				 points3[3*mesh.av[5][i]],points3[3*mesh.av[5][i]+1],points3[3*mesh.av[5][i]+2],0);
		buffer4data.push(points4[3*i],points4[3*i+1],points4[3*i+2],0,
				 points4[3*mesh.av[0][i]],points4[3*mesh.av[0][i]+1],points4[3*mesh.av[0][i]+2],0,
				 points4[3*mesh.av[1][i]],points4[3*mesh.av[1][i]+1],points4[3*mesh.av[1][i]+2],0,
				 points4[3*mesh.av[2][i]],points4[3*mesh.av[2][i]+1],points4[3*mesh.av[2][i]+2],0,
				 points4[3*mesh.av[3][i]],points4[3*mesh.av[3][i]+1],points4[3*mesh.av[3][i]+2],0,
				 points4[3*mesh.av[4][i]],points4[3*mesh.av[4][i]+1],points4[3*mesh.av[4][i]+2],0,
				 points4[3*mesh.av[5][i]],points4[3*mesh.av[5][i]+1],points4[3*mesh.av[5][i]+2],0);
	}

	/* for (var i = 0; i < mesh.points_spherical.length/2*3*7; i++) {
		buffer0data.push(Math.random());
		buffer1data.push(Math.random());
		buffer2data.push(Math.random());
		buffer3data.push(Math.random());
		buffer4data.push(Math.random());
	} */

	

	buffer0 = gl.createBuffer();
	buffer1 = gl.createBuffer();
	buffer2 = gl.createBuffer();
	buffer3 = gl.createBuffer();
	buffer4 = gl.createBuffer();

	gl.bindBuffer(gl.ARRAY_BUFFER, buffer0);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer0data), gl.STATIC_DRAW);
   	gl.bindBuffer(gl.ARRAY_BUFFER, buffer1);
   	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer1data), gl.STATIC_DRAW);
   	gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
   	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer2data), gl.STATIC_DRAW);
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer3);
   	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer3data), gl.STATIC_DRAW);
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer4);
   	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer4data), gl.STATIC_DRAW);

	

   	indexBuffer = gl.createBuffer();
   	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
   	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.triangles), gl.STATIC_DRAW);
	drawLength = mesh.triangles.length;
	tLoc = [gl.getUniformLocation(prog, "t"), gl.getUniformLocation(prog2, "t")];
   	mvpMatrixLoc = [gl.getUniformLocation(prog, "u_modelViewProjMatrix"),gl.getUniformLocation(prog2, "u_modelViewProjMatrix")];
   	mvMatrixLoc = [gl.getUniformLocation(prog, "modelViewMatrix"),gl.getUniformLocation(prog2, "modelViewMatrix")];
   	basecolorLoc = [gl.getUniformLocation(prog, "basecolor"),gl.getUniformLocation(prog2, "basecolor")];
   	shininessLoc = [gl.getUniformLocation(prog, "shininess"),gl.getUniformLocation(prog2, "shininess")];
	gl.useProgram(prog);   	
	gl.uniform3f(basecolorLoc[0], 0.0, 1.0, 0.0);
	gl.uniform1f(shininessLoc[0], 0.0);
	gl.useProgram(prog2);
	gl.uniform3f(basecolorLoc[1], 0.0, 1.0, 0.0);
   	gl.uniform1f(shininessLoc[1], 0.0);
   	gl.clearColor(0,0,0,1);
   	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	
	rotMatrix = new J3DIMatrix4();

	projectionMatrix = new J3DIMatrix4();
        projectionMatrix.perspective(45, maincanvas.clientWidth / maincanvas.clientHeight, 0.1, 100.0);
	projmat = projectionMatrix.getAsArray();
	modelviewMatrix = new J3DIMatrix4();
	modelviewMatrix.load([1,0,0,0,0,1,0,0,0,0,1,0,0,0,-5,1]);
	projectionMatrix.multiply(modelviewMatrix);
	gl.useProgram(prog);
	projectionMatrix.setUniform(gl, mvpMatrixLoc[0], false);
	gl.useProgram(prog2);
	projectionMatrix.setUniform(gl, mvpMatrixLoc[1], false);
	gl.useProgram(prog);	
	gl.uniformMatrix3fv(mvMatrixLoc[0], false, [1,0,0,0,1,0,0,0,1]);
	gl.useProgram(prog2);
	gl.uniformMatrix3fv(mvMatrixLoc[1], false, [1,0,0,0,1,0,0,0,1]);
   	initialized = true;
    }

		
    function drawScene(t, stage) {
	gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    	if (stage==1) { //beginning sphere -> corrugations
		gl.useProgram(prog2);
		gl.uniform1f(tLoc[1],t);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer0);
		for (var i = 0; i < 7; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*i*4);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer1);
		for (var i = 7; i < 14; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*(i-7)*4);	
	}
	if (stage==2) { //corrugations -> switch poles
		gl.useProgram(prog2);
		gl.uniform1f(tLoc[1],t);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer1);
		for (var i = 0; i < 7; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*i*4);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
		for (var i = 7; i < 14; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*(i-7)*4);			
	}
	if (stage==3) { //poles switched -> twist
		gl.useProgram(prog);
		gl.uniform1f(tLoc[0],t);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
		for (var i = 0; i < 7; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*i*4);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer3);
		for (var i = 7; i < 14; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*(i-7)*4);
	}    
	if (stage==4) { //uncorrugate
		gl.useProgram(prog2);
		gl.uniform1f(tLoc[1],t);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer3);
		for (var i = 0; i < 7; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*i*4);
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer4);
		for (var i = 7; i < 14; i++) gl.vertexAttribPointer(i, 4, gl.FLOAT, false, 4*7*4, 4*(i-7)*4);	
	}
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);
	gl.drawElements(gl.TRIANGLES, drawLength/8, gl.UNSIGNED_SHORT, drawLength-drawLength/8);
    }


    /* function tick() {
        requestAnimFrame(tick, maincanvas);
        gl.useProgram(prog);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        gl.viewport(0, 0, m, m);
	if (currentSampler==0) {
        gl.uniform1i(samp, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, FBO1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.POINTS, 0, numPts);
	currentSampler = 1;
	} else {
        gl.uniform1i(samp, 1);
        gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.POINTS, 0, numPts);
	currentSampler = 0;
	}
	drawScene();
    } */

    var maincanvas, colorcanvas, colorctx, baseRotQ, dragBaseX, dragBaseY, projmat;
    var mainDrag = false;
    var colorDrag = false;
    var initialized = false;
    var t = 0;

    function webGLStart() {
        maincanvas = document.getElementById("example");
        gl = WebGLUtils.setupWebGL(maincanvas);
	maincanvas.width = maincanvas.clientWidth;
	maincanvas.height = maincanvas.clientHeight;
        initShaders();
        document.getElementById("damping").value = 0.0;
	updateValue("dampingValue","0");
	document.getElementById("speed").value = 1.0;
	updateValue("tValue","1");
	document.getElementById("shininess").value = 0.0;
	updateValue("shineValue","0");
	document.getElementById("stiffness").value = 1.0;
	updateValue("stiffValue","1");
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.clearDepth(100);
	maincanvas.addEventListener("mousedown",handleMouseDown,false);
	document.documentElement.onmouseup = function() {mainDrag = false; colorDrag = false};
	document.documentElement.onmouseleave = function() {mainDrag = false; colorDrag = false};
	document.documentElement.onmousemove = function(event) {handleMouseMove(event)};
	colorcanvas = document.getElementById("colorcanvas");
        colorctx = colorcanvas.getContext("2d");
	colorcanvas.addEventListener("mousedown", function (event) {colorDrag = true;
		handleMouseMove(event);}, false);
	colormousemove(55,10);
	document.getElementById("loading").innerHTML = "";

        drawScene(t,3);
    }

    function handleMouseMove(evt) {
	if (mainDrag) {
	rotate(evt.clientX, evt.clientY);
	drawScene(t,3);
	}
	else if (colorDrag) {
	var rect = colorcanvas.getBoundingClientRect();
	colormousemove(evt.clientX-rect.left, evt.clientY-rect.top);
	drawScene(t,3);
	}
    }

    function updateValue(id,value) {
	if (initialized) {
	var val = Number(value);
	if (id=='shineValue') {
		gl.useProgram(prog);
		gl.uniform1f(shininessLoc[0],val);
		gl.useProgram(prog2);
		gl.uniform1f(shininessLoc[1],val);
		document.getElementById("shineval").innerHTML = value;
		drawScene(t,3);		
	}
	if (id=="speedValue") {
		t = val;
		drawScene(t,3);
	}
	}
    }

    function rotate(x,y) {
	var dx = x-dragBaseX;
	var dy = y-dragBaseY;
	var norm = Math.sqrt(dx*dx+dy*dy);
	if (norm > 0) {
	dx = dx/norm;
	dy = dy/norm;
	}
	curRotQ = qMultiply(baseRotQ,[Math.cos(norm/200),-dy*Math.sin(norm/200),-dx*Math.sin(norm/200),0]);
	modelviewMatrix.load([1,0,0,0,0,1,0,0,0,0,1,0,0,0,-5,1]);
	curRotQ = qNormalize(curRotQ);
	qr = curRotQ[0];
	qi = curRotQ[1];
	qj = curRotQ[2];
	qk = curRotQ[3];
	mat = [1-2*qj*qj-2*qk*qk, 2*(qi*qj-qk*qr), 2*(qi*qk+qj*qr), 0,
		2*(qi*qj+qk*qr), 1-2*qi*qi-2*qk*qk, 2*(qj*qk-qi*qr), 0,
		2*(qi*qk-qj*qr), 2*(qj*qk+qi*qr), 1-2*qi*qi-2*qj*qj, 0,
		0, 0, 0, 1];
	rotMatrix.load(mat);
	gl.useProgram(prog);
	gl.uniformMatrix3fv(mvMatrixLoc[0], false, [mat[0],mat[1],mat[2],mat[4],mat[5],mat[6],mat[8],mat[9],mat[10]]);
	gl.useProgram(prog2);
	gl.uniformMatrix3fv(mvMatrixLoc[1], false, [mat[0],mat[1],mat[2],mat[4],mat[5],mat[6],mat[8],mat[9],mat[10]]);
	modelviewMatrix.multiply(rotMatrix);
	
	projectionMatrix.load(projmat);
	projectionMatrix.multiply(modelviewMatrix);
	gl.useProgram(prog);
	projectionMatrix.setUniform(gl, mvpMatrixLoc[0], false);
	gl.useProgram(prog2);
	projectionMatrix.setUniform(gl, mvpMatrixLoc[1], false);	
    }

    function handleMouseDown(evt){
	if (evt.button==0 && initialized) {
		mainDrag = true;
		dragBaseX = evt.clientX;
		dragBaseY = evt.clientY;
		baseRotQ = curRotQ;
	}
    }

   function colormousemove(x,y) {
	if (x > 135) x = 135;
	if (x < 15) x = 15;
	colorctx.clearRect(0,0,150,20);
	var grd = colorctx.createLinearGradient(15,0,120,0);
	grd.addColorStop(0,"#FF0808");
	grd.addColorStop(0.333,"#08FF08");
	grd.addColorStop(0.666,"#0808FF");
	grd.addColorStop(1.0,"#FF0808");
	colorctx.fillStyle = grd;
	colorctx.fillRect(15,7,120,6);
	colorctx.fillStyle = "#DC143C";
	colorctx.beginPath();
	colorctx.arc(x,10,5,0,2*Math.PI,false);
	colorctx.fill();
	var xscale = (x-15)/40.0;
	var hColor;
	if (xscale <= 1) {
		hColor = [1-xscale, 0.8*xscale+0.2,0];
	} else if (xscale <= 2) {
		hColor = [0, 0.8*(2-xscale)+0.2, xscale-1];
	} else {
		hColor = [1-(xscale-3)*(xscale-3), 0.2, 1-(xscale-2)*(xscale-2)];
	}
	gl.useProgram(prog);	
	gl.uniform3f(basecolorLoc[0], hColor[0], hColor[1], hColor[2]);
	gl.useProgram(prog2);
	gl.uniform3f(basecolorLoc[1], hColor[0], hColor[1], hColor[2]);
    }
	
		
</script>
</head>

<body onload="webGLStart()">
<canvas id="example"></canvas>
<div id="loading"><h1>Loading...</h1></div>
<div id="controls">
Elasticity: <div id="stiffval" style="display: inline"></div>
<div class="slider"><input class="range" id="stiffness" min="0.0" max="2.0" value="1.0" step="0.1" oninput="updateValue('stiffValue', this.value)" type="range" onchange="updateValue('stiffValue', this.value)"> </div>
<br>
Damping: <div id="dampval" style="display: inline"></div>
<div class="slider"><input class="range" id="damping" min="0.0" max="1.0" value="0.0" step="0.1" oninput="updateValue('dampingValue', this.value)" type="range" onchange="updateValue('dampingValue', this.value)"> </div>
<br>
Speed: <div id="speedval" style="display: inline"></div>
<div class="slider"><input class="range" id="speed" min="0.0" max="2.0" value="1.0" step="0.01" oninput="updateValue('speedValue', this.value)" type="range" onchange="updateValue('speedValue', this.value)"> </div>
<br>
Shininess: <div id="shineval" style="display: inline"></div>
<div class="slider"><input class="range" id="shininess" min="0.0" max="1.0" value="0.0" step="0.1" oninput="updateValue('shineValue', this.value)" type="range" onchange="updateValue('shineValue', this.value)"> </div>
<br>
Color:
<br>
<canvas id="colorcanvas" width="150px" height="20px"></canvas>
<br>
With jitter:
<br>
<button type="button" onclick="loadInitialValues('classic',1)">Classic</button>
<button type="button" onclick="loadInitialValues('pulse',1)">Pulse</button>
<button type="button" onclick="loadInitialValues('doublepulse',1)">Double Pulse</button>
<br>
<br>
Without jitter:
<br>
<button type="button" onclick="loadInitialValues('classic',0)">Classic</button>
<button type="button" onclick="loadInitialValues('pulse',0)">Pulse</button>
<button type="button" onclick="loadInitialValues('doublepulse',0)">Double Pulse</button>
<br>
<br>
Spherical harmonics:
<br>
<button type="button" onclick="loadInitialValues('ml04',0)">L=4, M=0</button>
<button type="button" onclick="loadInitialValues('ml14',0)">L=4, M=1</button>
<button type="button" onclick="loadInitialValues('ml24',0)">L=4, M=2</button>
<button type="button" onclick="loadInitialValues('ml34',0)">L=4, M=3</button>
<button type="button" onclick="loadInitialValues('ml44',0)">L=4, M=4</button>
<br>
<br>
<button type="button" onclick="loadInitialValues('ml02',0)">L=2, M=0</button>
<button type="button" onclick="loadInitialValues('ml12',0)">L=2, M=1</button>
</div>
<br>
<div id="text">
<hr>
Click and drag to rotate
<br>
<br>
To freeze animations, you can set the "Speed" slider to zero
<br>
<br>
If this doesn't work or runs slowly in your browser, you might want to try this <a href = "elasticsphere.html" style="color:GreenYellow">older version.</a>
<hr>
<h1>Math notes</h1>
<br>
The wave equation for a function <i>f</i> is
<h2 style="text-align:center"><i>f<sub>tt</sub></i> = &#x2207<sup>2</sup><i>f</i></h2>
where &#x2207<sup>2</sup> is the Laplacian, and <i>f<sub>tt</sub></i> is the second partial derivative of <i>f</i>
with respect to time.  The exact definition of the Laplacian depends on the space that <i>f</i> lives on,
but the basic idea is that the Laplacian measures how concave or convex the graph of <i>f</i> is.  On the real line, the Laplacian is just the ordinary
second derivative used to determine whether <i>f</i> is concave up or down.  In three dimensional Euclidean space,
the Laplacian is &#x2207<sup>2</sup><i>f</i>(<i>x,y,z</i>)=<i>f<sub>xx</sub>+f<sub>yy</sub>+f<sub>zz</sub></i>.
<br>
<br>
Defining the Laplacian on a curved surface is a little trickier.  If you want to get really fancy, you can use the metric
on the surface to define the so-called <a href="http://en.wikipedia.org/wiki/Laplace-Beltrami_operator" style="color:GreenYellow">Laplace-Beltrami operator</a>.
For the two-dimensional sphere <i>S</i> defined by <i>x</i><sup>2</sup>+<i>y</i><sup>2</sup>+<i>z</i><sup>2</sup> = 1, there is a much easier approach that doesn't require differential geometry.  Given a real-valued function <i>f</i> on <i>S</i>, we can extend it to all of 3-space minus the origin as follows: using vector notation <i>v</i> = (<i>x,y,z</i>), let <i>f</i>(<i>v</i>) = <i>f</i>(<i>v/|v|</i>), where <i>|v|</i> = (<i>x</i><sup>2</sup>+<i>y</i><sup>2</sup><i>+z</i><sup>2</sup>)<sup>1/2</sup>.  Then just use the regular Laplacian on 3-space from before.  This works for higher-dimensional spheres as well.
<br>
<br>
The wave equation gets its name from modeling wave propagation on an elastic string or thin surface.  The basic idea is that <i>f</i> measures displacement of the string or surface from equilibrium.  If this displacement isn't too big, then up to a constant, &#x2207<sup>2</sup><i>f</i> is a good approximation to the force on the medium caused by tension.  (This constant can be thought of as the "spring constant" measuring elasticity or stiffness, which can be changed in the simulation by adjusting the "Elasticity" slider.)  According to Newton's law, force is proportional to acceleration, which is <i>f<sub>tt</sub></i>.  Setting these two things equal gives the wave equation.
<br>
<br>
This program uses the numerical method from
<a href="http://www.giseis.alaska.edu/input/carl/research/pubs/thesis/membrane_cht_THESIS.pdf" style="color:GreenYellow">this paper</a> to approximate the wave equation on a sphere.  The most popular numerical methods for PDEs are <a href="http://en.wikipedia.org/wiki/Finite_difference_method" style="color:GreenYellow">finite difference methods</a> that work by approximating functions with their values on a discrete grid.  Derivatives at each point are approximated by looking at adjacent values on the grid.  In this case we use a triangular mesh on the sphere made up of about 2,000 points.  To approximate the Laplacian, the paper uses the <a href="http://en.wikipedia.org/wiki/Divergence_theorem" style="color:GreenYellow">divergence theorem</a> from vector calculus (which is also true on surfaces) applied to the gradient of <i>f</i>, and the fact that the Laplacian is equal to the divergence of the gradient.
<br>
<br>
Special solutions of the wave equation can be built from <a href="http://en.wikipedia.org/wiki/Spherical_harmonics" style="color:GreenYellow">spherical harmonics</a>, real valued functions <i>Y</i>(<i>v</i>) on the sphere which are eigenfunctions of the Laplacian.  Eigenfunction means that &#x2207<sup>2</sup><i>Y</i>(<i>v</i>) = -&#x3bb<i>Y</i>(<i>v</i>) for some constant &#x3bb.  If &#x3bb is positive, then it is easy to check that <i>f</i>(<i>v,t</i>) = cos(&#x3bb<sup>1/2</sup><i>t</i>)<i>Y</i>(<i>v</i>) is a solution of the wave equation.  Since <i>Y</i>(<i>v</i>) does not depend on time, <i>f</i>(<i>v,t</i>) will be a constant multiple of <i>Y</i>(<i>v</i>) at all times.  Graphing <i>f</i>(<i>v,t</i>) gives a surface that pulses in and out but otherwise does not change shape.  Checking that the solution has this behavior is one way to check whether a numerical method is accurate.  
<br>
<br>
The buttons in the program let you try different spherical harmonics as initial conditions.  The value of L on the button is defined in terms of the eigenvalue &#x3bb, while the M has to do with the fact that by definition, spherical harmonics are also eigenfunctions of another differential operator, an angular momentum operator used in quantum mechanics.  (Spherical harmonics show up in the solution to Schrodinger's equation for an atom with one electron, and actually define the shape of the orbitals that you see in chemistry books.  They are also related to the shape of the periodic table.)  For some of the spherical harmonics, the shapes have the expected pulsing behavior, but for others, they gradually become distorted.  This is interesting to watch, but means that the numerical method being used in the program is inaccurate.  Since it was designed for speed rather than accuracy, this isn't too surprising.  Another way to see inaccuracies is to note that the "Pulse" function starts out with an axis of symmetry that should be preserved by the wave equation, but quickly breaks down in the program.
<br>
<br>
It's interesting to think about why some of the harmonics are stable and others are not.  While I don't know exactly what is going on, I think this is because the stable harmonics (the three buttons with L=2, M=0; L=2, M=1; and L=4, M=2) have a certain configuration that the others do not.  We can look at all the points on the sphere where a given harmonic <i>Y</i>(<i>v</i>) equals zero.  In general, this will be a configuration of lines.  For the stable harmonics, at most two of the lines ever cross at a single point.  All of the unstable harmonics, except for L=4, M=0, have points where three or more lines cross.  This is not a stable configuration, because slightly wiggling any of the lines will turn the intersection point into three other intersection points where pairs of the lines cross instead of all three.  The L=4, M=0 harmonic actually has no line crossings, but it could be that the lines are still too close together to remain stable with this mesh size. 
<hr>
<h1>Programming notes</h1>
In addition to the graphics rendering, this program does all the calculations for the finite difference method on the GPU.  This is potentially faster than doing the calculations in JavaScript because the calculation for each gridpoint can be done in parallel, which GPUs are good at.  
<br>
<br>
Running the FDM on the GPU is done with a custom vertex shader and fragment shader.  In any WebGL program, the computer feeds arrays of data to the GPU, which are then processed with shaders.  For this program, the position and velocity at each point on the sphere are stored in what's called a "float texture", an array of floating point numbers that can be accessed anywhere in the vertex or fragment shader.  (Float textures are currently not built into core WebGL and require an extension.)  Textures were originally used to map patterns onto 3D shapes, but thanks to shaders, the data can be used pretty much however you want.  At each step of the FDM, the shaders calculate the new values and "render" them to another texture instead of the screen.  A different vertex/fragment shader are used to draw what you see on the screen.
<br>
<br>
This method can be used to do a lot of interesting things with WebGL.  As well as the many demos on Chrome Experiments, check out <a href="http://www.ibiblio.org/e-notes/webgl/gpu/contents.htm" style="color:GreenYellow">http://www.ibiblio.org/e-notes/webgl/gpu/contents.htm</a> and <a href=http://flexi23.pisces.uberspace.de/fmx/?full#21 style="color:GreenYellow">http://flexi23.pisces.uberspace.de/fmx/?full#21</a>.
<br>
<br>
There are some drawbacks with using the GPU for calculations.  For instance, it's hard (at least with the current WebGL standard) to get data from a float texture back onto the CPU so you can do stuff with it in JavaScript.  This can make it hard to add interactive features.
<hr>
<br>
<br>
<br>
</div>
</body>
<script src="mesh_large.js"></script>
<script src="J3DIMath.js"></script>
<script src="webgl-utils.js"></script>
